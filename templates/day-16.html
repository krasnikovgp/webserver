{% extends "base.html" %}

{% block navigation %}
<nav class="blog-navigation">
  <a href="{{ url_for('start') }}">На главную</a>
</nav>
{% endblock %}

{% block content %}
<main>
  <article>
    <h1>День шестнадцатый. Flask</h1>
    <p>Flask - это упрощенная платформа Python для веб-приложений, которая обеспечивает основные возможности маршрутизации URL-адресов и визуализации страниц.</p>
    <p>Проще говоря, это бекэнд самого сайта, который реализует всю логику проекта.</p>
    <div class="abc"><img src="{{ url_for('static', filename='files/flask.jpg') }}" width="250" height="250">
      <p class="abc1">Код будем писать в файле server.py.
        Из пакета flask нужно импортировать класс WCGI-приложения, на основе которого нужно будет создать новый объект:</p>
      <pre>
from flask import Flask
app = Flask(__name__)
      </pre>
    </div>
    <div class="abc">
      <p class="abc2">Чтобы пользователь мог получить какой-то ответ при запросе по открытому адресу, этот ответ должен быть сформирован функцией.
        Она должна быть объявлена сразу под декоратором, открывающим путь (поэтому говорят, что функция декорирована),
        и возвращать строку, которую потом сможет интерпретировать браузер:</p>
      <pre>
@app.route('/')
    def hello():
        return 'Hello, World!'
      </pre>
    </div>
    <div class="abc">
      <div class="ch">
      <pre>
if __name__ == '__main__':
    app.run()
      </pre>
      </div>
      <p class="abc2">Сервер запускается с помощью метода run объекта app.
        Хорошим тоном считается вызывать этот метод только в том случае, если server.py запускается напрямую.
        В этом случае его атрибут __name__ (т.е. название скрипта) примет значение __main__, а не server.py, как было бы при его импорте.
        Для того чтобы учесть эту ситуацию, есть специальная конструкция (в PyCharm ее можно получить, просто набрав слово main и нажав Enter):</p>
    </div>

  </article>
  <aside class="partnership">
    Тут могла быть ваша реклама
  </aside>
</main>
{% endblock %}